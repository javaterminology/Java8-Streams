http://ronnieroller.com/java/date-times
https://www.toptal.com/java/spring-boot-rest-api-error-handling

stackoverflow error/Outofmemory error
RestTemplateAdvice/RestControllerAdvice
CheckedException/UncheckedException - custom exception is checked or unchecked exception?
Hibernate - One to Many(1000 records) fetch="eager" is theere any performance issue?
In Functional interface if we have same method with overloaded signature as just like abstract? what will happen?
stream vs parallel stream ..should i use always parallel stream for better performance?
HashMap insertion order if we get by keys ?
Comparator can we apply for Maps?
TreeMap sorting order?
Executors if i give 1000 thread pool size for collection of 1000 objects will we get good performance? No
Springboot advantages?
Hibernate n+1 problem?
Sonarcube?
JaCoco maven plugin?
JUnit integration testing?
Mongodb when to use?
propagation levels- REQUIRED,REQUIRES-NEW when to use them?
Spring AOP - pointcut,advice,joinpoint
MongoDB:
TO SEE QUERY EXECUTION STATISTICS:
db.getCollection('collection-name').find({}).explain("executionStats");
--create index in mongodb for columns
db.COLLECTION-NAME.createIndex({ student: 1, type: 1 });
--create index programatically using spring data mongodb

@Document
@CompoundIndex(def = "{'firstName':1, 'salary':1}", name = "person_index")
public class Person {
  @Id private String id;


@Mock creates a mock. @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance. 
Note that you must use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialise these mocks and inject them.

@RunWith(MockitoJUnitRunner.class)
public class SomeManagerTest {

    @InjectMocks
    private SomeManager someManager;

    @Mock
    private SomeDependency someDependency; // this will be injected into someManager

     //tests...

}
