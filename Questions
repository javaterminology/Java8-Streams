
http://ronnieroller.com/java/date-times
https://www.toptal.com/java/spring-boot-rest-api-error-handling

>> stackoverflow error/Outofmemory error
>> RestTemplateAdvice/RestControllerAdvice
>> CheckedException/UncheckedException - custom exception is checked or unchecked exception?
>> Hibernate - One to Many(1000 records) fetch="eager" is theere any performance issue?
>> In Functional interface if we have same method with overloaded signature as just like abstract? what will happen?
>> stream vs parallel stream ..should i use always parallel stream for better performance?
>> HashMap insertion order(inserted keys 1 to 100) can we get insertion order by keys ?
>> Comparator can we apply for Maps?
>> TreeMap sorting order?
>> Executors if i give 1000 thread pool size for collection of 1000 objects will we get good performance? No
>> Springboot advantages?
>> Hibernate n+1 problem?
>> Sonarcube?
>> JaCoco maven plugin?
>> JUnit integration testing?
>> Mongodb when to use?
>> propagation levels- REQUIRED,REQUIRES-NEW when to use them?
>> Spring AOP - pointcut,advice,joinpoint

>> with out using component scan in springboot how do u inject dependency class into dependent class?
	using spring.factories - src/main/resources/META-INF/spring.factories
	ex: org.springframework.boot.env.EnvironmentPostProcessor = com.example.hello.env.LocalSettingsEnvironmentPostProcessor
	https://github.com/snicoll-demos/hello-service-auto-configuration
	https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html
>> if suppose we have 2 data sources for u r application .. how do u ensure u r connecting to correct datasource in spring application.
	using Qualifier annotation
>> in hibernate how will u avoid partial commits - what is the annotation
#################################### JUNIT MOCKITO

@Mock creates a mock. @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance. 
Note that you must use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialise these mocks and inject them.

@RunWith(MockitoJUnitRunner.class)
public class SomeManagerTest {

    @InjectMocks
    private SomeManager someManager;

    @Mock
    private SomeDependency someDependency; // this will be injected into someManager

     //tests...

}

############################### SQL QUERY TO FORMAT DATE AS ISO FORMAT:
select TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD"T"HH24:MI:SS.FFTZR') from dual;
DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.sZ");
String s = sdf.format(new Date());

################################ MONGODB:
var now = new Date();
print(now.getTimezoneOffset());
db.mycollection.save( { date: now,
                offset: now.getTimezoneOffset() } );

db.getCollection('mycollection').find({});
var record = db.mycollection.findOne();
print(record); 
var localNow = new Date( record.date.getTime() -  ( record.offset * 60000 ) );
print(localNow); 

TO SEE QUERY EXECUTION STATISTICS:
db.getCollection('collection-name').find({}).explain("executionStats");
--create index in mongodb for columns
db.COLLECTION-NAME.createIndex({ student: 1, type: 1 });
--create index programatically using spring data mongodb

############################ save mongo collection date with iso format - mongodb by default stores date in UTC time stamp.
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createDate;
    
    //CREATE INDEX FOR MONGO COLLECTION
    @Document
    @CompoundIndex(def = "{'firstName':1, 'salary':1}", name = "person_index")
    public class Person {
    @Id private String id;
    
########################## NPM INSTALL
npm set repository http://registry.npmjs.org/
npm set proxy http://00:00:00:00:8080/ 
1.npm install
2.npm run build
3.npm start 

########################## spring data mongodb lookup operation - join with other collection
    Employee e =new Employee();
		e.set_id("1");
		e.setDept_id("100");
		e.setName("Raja");
		
		Department d = new Department();
		d.set_id("100");
		d.setDept_name("XYZ");
		
		
		this.mongoTemplate.insert(e, "employee");
		this.mongoTemplate.insert(d, "department");
		
		LookupOperation lookupOperation = LookupOperation.newLookup()
                .from("department")
                .localField("dept_id")
                .foreignField("_id")
                .as("departments");
	    Aggregation aggregation = Aggregation.newAggregation(
	    		match(new Criteria("_id").is("1")) , lookupOperation);
	    List<EmpDeptResult> results = mongoTemplate.aggregate(aggregation, Employee.class, EmpDeptResult.class).getMappedResults();
	    System.out.println(results);
	    this.mongoTemplate.dropCollection("employee");
	    this.mongoTemplate.dropCollection("department");
	    
	    >> https://stackoverflow.com/questions/44471800/spring-data-match-and-filter-nested-array
	    >> https://stackoverflow.com/questions/43470578/spring-data-mongo-db-query-embedded-array
	    >> https://stackoverflow.com/questions/44949720/spring-mongotemplate-mapping-aggregation-result-to-collections-e-g-list-and
	    >> https://github.com/spring-projects/spring-data-mongodb/blob/master/src/main/asciidoc/reference/mongo-repositories.adoc
		
		List<AggregationOperation> list = new ArrayList<AggregationOperation>();
		list.add(Aggregation.unwind("documentRequest"));
		list.add(Aggregation.unwind("documentRequest.documentDetails"));
		list.add(Aggregation.match(Criteria.where("documentRequest.documentDetails.docId").is("DOC1")));
		list.add(Aggregation.match(Criteria.where("documentRequest.documentDetails.customerId").is("11111111")));
		list.add(Aggregation.project().andExclude("_id"));
					ObjectMapper mapper = new ObjectMapper();
					mapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);

		TypedAggregation<DocumentRequestObj> agg = Aggregation.newAggregation(DocumentRequestObj.class, list);
		List<Document> dbObjects = mongoTemplate.aggregate(agg, "document_grouping", Document.class).getMappedResults();     
		System.out.println(dbObjects.get(0).toJson());
		//mongoTemplate.getConverter().read(DocumentRequestObj.class, dbObjects.get(0));


######################### Hibernate fetch strategy
@Entity
@Table
public class Parent {
    @Id
    private Long id;

    @OneToMany(mappedBy="parent", fetch = FetchType.EAGER)
    @Fetch(FetchMode.JOIN)
    private List<Child> child;    
    //getter setters
}

@Entity
@Table
public class Child {    
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Parent parent;

    //getter setter
}
In above example, when getting Parent entity, hibernate will automatically load all child entities eagerly using join. On the other hand, 
when you fetch Child, Parent entity won't be selected unless you call it explicity in your code child.getParent().
FetchType (Lazy/Eager) tells whether we want entity to be loaded eagerly or lazy, when there's call in code.
FetchMode (Select/Join) tells whether we want our entitity to be loaded with additional select or in one query with join or subselect.
>>FetchMode : It defines how hibernate (using which strategy, e.g. Join, SubQuery etc) will fetch data from database.
>>FetchType : It defines whether hibernate will fetch the data or not.
NOTE : FetchMode is only applicable when FetchType = EAGER while annotation.

>>https://docs.mulesoft.com/mule-user-guide/v/3.6/splitter-flow-control-reference#full-example-code-3
>>https://docs.mulesoft.com/mule-user-guide/v/3.6/scatter-gather
-------------Oracle 12c---------------------
alter session set container=orclpdb;
create user raja identified by raja;
grant create session to raja;
connect raja/raja@orclpdb;--pluggable database.	

//ELASTIC SEARCH
to see content of elastic index:
curl -H 'Content-Type: application/json' -X GET https://localhost:9200/index_name/_search?pretty
