http://ronnieroller.com/java/date-times
https://www.toptal.com/java/spring-boot-rest-api-error-handling

stackoverflow error/Outofmemory error
RestTemplateAdvice/RestControllerAdvice
CheckedException/UncheckedException - custom exception is checked or unchecked exception?
Hibernate - One to Many(1000 records) fetch="eager" is theere any performance issue?
In Functional interface if we have same method with overloaded signature as just like abstract? what will happen?
stream vs parallel stream ..should i use always parallel stream for better performance?
HashMap insertion order if we get by keys ?
Comparator can we apply for Maps?
TreeMap sorting order?
Executors if i give 1000 thread pool size for collection of 1000 objects will we get good performance? No
Springboot advantages?
Hibernate n+1 problem?
Sonarcube?
JaCoco maven plugin?
JUnit integration testing?
Mongodb when to use?
propagation levels- REQUIRED,REQUIRES-NEW when to use them?
Spring AOP - pointcut,advice,joinpoint
MongoDB:
TO SEE QUERY EXECUTION STATISTICS:
db.getCollection('collection-name').find({}).explain("executionStats");
--create index in mongodb for columns
db.COLLECTION-NAME.createIndex({ student: 1, type: 1 });
--create index programatically using spring data mongodb

@Document
@CompoundIndex(def = "{'firstName':1, 'salary':1}", name = "person_index")
public class Person {
  @Id private String id;


@Mock creates a mock. @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance. 
Note that you must use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialise these mocks and inject them.

@RunWith(MockitoJUnitRunner.class)
public class SomeManagerTest {

    @InjectMocks
    private SomeManager someManager;

    @Mock
    private SomeDependency someDependency; // this will be injected into someManager

     //tests...

}

ISO FORMAT:
select TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD"T"HH24:MI:SS.FFTZR') from dual;
DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.sZ");
String s = sdf.format(new Date());

mongodb:
var now = new Date();
print(now.getTimezoneOffset());
db.mycollection.save( { date: now,
                offset: now.getTimezoneOffset() } );

db.getCollection('mycollection').find({});
var record = db.mycollection.findOne();
print(record); 
var localNow = new Date( record.date.getTime() -  ( record.offset * 60000 ) );
print(localNow); 

//converting utc to hkt for mongo collection - mongodb by default stores date in UTC time stamp.

    @JsonFormat(timezone = "UTC+8", pattern = "yyyy-MM-dd HH:mm:ss")
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createDate;
    
//NPM INSTALL
npm set repository http://registry.npmjs.org/
npm set proxy http://00:00:00:00:8080/ 
1.npm install
2.npm run build
3.npm start 
