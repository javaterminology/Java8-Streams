
http://ronnieroller.com/java/date-times
https://www.toptal.com/java/spring-boot-rest-api-error-handling

stackoverflow error/Outofmemory error
RestTemplateAdvice/RestControllerAdvice
CheckedException/UncheckedException - custom exception is checked or unchecked exception?
Hibernate - One to Many(1000 records) fetch="eager" is theere any performance issue?
In Functional interface if we have same method with overloaded signature as just like abstract? what will happen?
stream vs parallel stream ..should i use always parallel stream for better performance?
HashMap insertion order(inserted keys 1 to 100) can we get insertion order by keys ?
Comparator can we apply for Maps?
TreeMap sorting order?
Executors if i give 1000 thread pool size for collection of 1000 objects will we get good performance? No
Springboot advantages?
Hibernate n+1 problem?
Sonarcube?
JaCoco maven plugin?
JUnit integration testing?
Mongodb when to use?
propagation levels- REQUIRED,REQUIRES-NEW when to use them?
Spring AOP - pointcut,advice,joinpoint
#################################### JUNIT MOCKITO

@Mock creates a mock. @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy) annotations into this instance. 
Note that you must use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialise these mocks and inject them.

@RunWith(MockitoJUnitRunner.class)
public class SomeManagerTest {

    @InjectMocks
    private SomeManager someManager;

    @Mock
    private SomeDependency someDependency; // this will be injected into someManager

     //tests...

}

############################### SQL QUERY TO FORMAT DATE AS ISO FORMAT:
select TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DD"T"HH24:MI:SS.FFTZR') from dual;
DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.sZ");
String s = sdf.format(new Date());

################################ MONGODB:
var now = new Date();
print(now.getTimezoneOffset());
db.mycollection.save( { date: now,
                offset: now.getTimezoneOffset() } );

db.getCollection('mycollection').find({});
var record = db.mycollection.findOne();
print(record); 
var localNow = new Date( record.date.getTime() -  ( record.offset * 60000 ) );
print(localNow); 

TO SEE QUERY EXECUTION STATISTICS:
db.getCollection('collection-name').find({}).explain("executionStats");
--create index in mongodb for columns
db.COLLECTION-NAME.createIndex({ student: 1, type: 1 });
--create index programatically using spring data mongodb

############################ save mongo collection date with iso format - mongodb by default stores date in UTC time stamp.

   
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime createDate;
    
    //CREATE INDEX FOR MONGO COLLECTION
    @Document
    @CompoundIndex(def = "{'firstName':1, 'salary':1}", name = "person_index")
    public class Person {
    @Id private String id;
    
########################## NPM INSTALL
npm set repository http://registry.npmjs.org/
npm set proxy http://00:00:00:00:8080/ 
1.npm install
2.npm run build
3.npm start 

########################## spring data mongodb lookup operation - join with other collection
    Employee e =new Employee();
		e.set_id("1");
		e.setDept_id("100");
		e.setName("Raja");
		
		Department d = new Department();
		d.set_id("100");
		d.setDept_name("XYZ");
    
LookupOperation lookupOperation = LookupOperation.newLookup()
                .from("Department")
                .localField("dept_id")
                .foreignField("_id")
                .as("departments");
	    Aggregation aggregation = Aggregation.newAggregation(Aggregation.match(Criteria.where("_id").is("1")) , lookupOperation);
	    List<EmpDeptResult> results = mongoTemplate.aggregate(aggregation, "Employee", EmpDeptResult.class).getMappedResults();
	    System.out.println(results);
	    
>>with out using component scan in springboot how do u inject dependency class into dependent class?
	using session.factories - src/main/resources/META-INF/services/session.factories - define complete class path
>>if suppose we have 2 data sources for u r application .. how do u ensure u r connecting to correct datasource in spring application.
	using Qualifier annotation
>>in hibernate how will u avoid partial commits - what is the annotation

######################### Hibernate fetch strategy
@Entity
@Table
public class Parent {
    @Id
    private Long id;

    @OneToMany(mappedBy="parent", fetch = FetchType.EAGER)
    @Fetch(FetchMode.JOIN)
    private List<Child> child;    
    //getter setters
}


@Entity
@Table
public class Child {    
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Parent parent;

    //getter setter
}
In above example, when getting Parent entity, hibernate will automaticly load all child entities eagerly using join. On the other hand, when you fetch Child, Parent entity won't be selected unless you call it explicity in your code child.getParent().
FetchType (Lazy/Eager) tells whether we want entity to be loaded eagerly or lazy, when there's call in code.
FetchMode (Select/Join) tells whether we want our entitity to be loaded with additional select or in one query with join or subselect.
FetchMode : It defines how hibernate (using which strategy, e.g. Join, SubQuery etc) will fetch data from database.
FetchType : It defines whether hibernate will fetch the data or not.
NOTE : FetchMode is only applicable when FetchType = EAGER while annotation.
